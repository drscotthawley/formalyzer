# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['read_text_file', 'read_urls_file', 'read_pdf_text', 'scrape_form_fields', 'trim_fields', 'make_prompt',
           'get_field_mappings', 'get_element_info', 'should_skip', 'fill_element', 'fill_form',
           'upload_recommendation', 'process_url', 'read_info', 'setup_browser', 'run_formalyzer', 'main']

# %% ../nbs/00_core.ipynb 4
import os 

def read_text_file(filename:str) -> list:
    "generic, read any text file" 
    with open(os.path.expanduser(filename)) as f:
        return f.read()

# %% ../nbs/00_core.ipynb 6
def read_urls_file(urls_file:str) -> list:
    "read a text file where each line is a url of a submission site" 
    return [line for line in read_text_file(urls_file).splitlines() if line]

# %% ../nbs/00_core.ipynb 8
from pypdf import PdfReader
import logging
logging.getLogger("pypdf").setLevel(logging.ERROR)

def read_pdf_text(pdf_file:str):
    reader = PdfReader(os.path.expanduser(pdf_file))
    return "\n".join(page.extract_text() for page in reader.pages)

# %% ../nbs/00_core.ipynb 11
from bs4 import BeautifulSoup
import json, re


def scrape_form_fields(html:str) -> list[dict]:
    """Extract all fillable form fields from HTML"""
    soup = BeautifulSoup(html, 'html.parser')
    fields = []
    for inp in soup.find_all(['input', 'select', 'textarea']):
        field_id = inp.get('id') or inp.get('name', '')
        if not field_id: continue
        field_type = inp.get('type', inp.name)
        if field_type in ['hidden', 'submit', 'button']: continue
        
        label = soup.find('label', {'for': field_id})
        label_text = label.get_text(strip=True) if label else ''
        current_value = inp.get('value', '')
        
        options = None
        if inp.name == 'select':
            options = [opt.get_text(strip=True) for opt in inp.find_all('option') if opt.get_text(strip=True)]
        
        fields.append({
            'id': field_id, 'label': label_text, 'type': field_type,
            'options': options, 'prefilled': bool(current_value and field_type not in ['radio','checkbox'] and inp.name != 'select')
        })
    return fields

# %% ../nbs/00_core.ipynb 14
def trim_fields(fields: list[dict]) -> list[dict]:
    """remove unnecessary fields so that we send fewer tokens to the LLM: 
    Remove prefilled fields and drop options from non-select fields"""
    trimmed = []
    for f in fields:
        if f['prefilled']: continue
        f.pop('prefilled', None)
        if f['type'] != 'select': f.pop('options', None)
        if f.get('label') == '': f.pop('label', None)
        trimmed.append(f)
    return trimmed

# %% ../nbs/00_core.ipynb 16
def make_prompt(fields:list[dict], recc_info:str, letter_text:str) -> str:
    "build the prompt that will go to the LLM"
    return f"""You are filling out a graduate school recommendation form.

RECOMMENDER INFO:
{recc_info}

RECOMMENDATION LETTER:
{letter_text}

FORM FIELDS TO FILL:
{json.dumps(fields, separators=(',', ':'))}

For each field, provide the field ID and value to fill. 
Be careful to use ONLY the exact field IDs provided! 
For dropdowns, pick from the options listed.
Pay attention to groups of radio buttons (grouped via div or similar id prefixes) as they may form likert scales.
Return as JSON array: [{{"id": "form_xxx", "value": "..."}}]
"""

# %% ../nbs/00_core.ipynb 18
import re 

def get_field_mappings(
        fields:list[dict],  # list of form fields
        recc_info:str,      # info on recommending person
        letter_text:str,    # text of recc letter
        model='claude-sonnet-4-20250514',  # LLM choice, e.g. "ollama/qwen2.5:14b" 
        debug=False,        # print debugging/status info
        ):
    """Use LLM to map recommender info and letter to form fields"""
    if 'claude' in model.lower():
        from claudette import Chat
    else:
        from lisette import Chat

    prompt = make_prompt(trim_fields(fields), recc_info, letter_text)

    chat = Chat(model=model)
    if debug: print(f"  Prompt length is {len(prompt)} characters")
    response = chat(prompt)
    content_text = response.content[0].text if hasattr(response, 'content') else response.choices[0].message.content
    content_text = re.sub(r'//.*', '', content_text) # llm may have added JS-style comments, we don't want
    if debug: print(f"LLM response:\n{content_text}\n")
    json_match = re.search(r'```json\s*(.*?)\s*```', content_text, re.DOTALL)
    return json.loads(json_match.group(1))

# %% ../nbs/00_core.ipynb 20
async def get_element_info(page, field_id):
    "given an id or a name, find the element on the page and get its info"
    elem = page.locator(f'#{field_id}, [name="{field_id}"]')
    await elem.wait_for(timeout=1000) # 1 second. default timeout for non-found fields is 30 seconds.
    tag = await elem.evaluate('el => el.tagName.toLowerCase()')
    input_type = await elem.evaluate('el => el.type')
    return elem, tag, input_type

# %% ../nbs/00_core.ipynb 21
async def should_skip(elem, tag, input_type, skip_prefilled) -> bool:
    "should we fill in this element? Not if there's already a value there."
    if skip_prefilled and tag != 'select' and input_type != 'radio':
        current = await elem.input_value()
        if current: return True # there's already a value provided, skip it
    return False

# %% ../nbs/00_core.ipynb 22
async def fill_element(elem, tag, input_type, field_id, value):
    "actually fill in this element"
    if tag == 'select':
        await elem.select_option(label=value)
    else:
        if input_type == 'radio':
            print(f"  Clicking radio button {field_id} with value {value}")
            await elem.click()
        else:
            await elem.fill(value)   

# %% ../nbs/00_core.ipynb 23
async def fill_form(page, mappings, skip_prefilled=True, debug=False):
    """Fill form fields using Playwright"""
    results = {'filled': [], 'skipped': [], 'errors': []}
    for i, item in enumerate(mappings):
        field_id, value = item['id'], item['value']
        if debug: print(f"Mapping {i+1} of {len(mappings)}:  Processing {field_id}...")
        try:
            elem, tag, input_type = await get_element_info(page, field_id)
            
            if await should_skip(elem, tag, input_type, skip_prefilled):
                results['skipped'].append(field_id)
                continue
            
            await fill_element(elem, tag, input_type, field_id, value)
            results['filled'].append(field_id)
        except Exception as e:
            print(f"  Error filling {field_id}: {e}")
            results['errors'].append({'id': field_id, 'error': str(e)[:50]})
    return results

# %% ../nbs/00_core.ipynb 24
async def upload_recommendation(page, file_path):
    """Upload the recommendation PDF"""
    file_input = page.locator('input[type="file"]').first
    await file_input.set_input_files(file_path)

# %% ../nbs/00_core.ipynb 25
async def process_url(page, url, recc_info, letter_text, pdf_path, model, debug=False):
    """Process a single recommendation URL"""
    await page.goto(url)
    html = await page.content()
    
    if debug: print("Scraping form fields")
    fields = scrape_form_fields(html)
    if debug: print(f"Found {len(fields)} fields")
    
    if debug: print(f"Calling LLM ({model}) to get field mappings")
    mappings = get_field_mappings(fields, recc_info, letter_text, model=model, debug=debug)
    if debug: print(f"Got {len(mappings)} mappings from LLM")
    
    if debug: print("Filling in form")
    results = await fill_form(page, mappings, debug=debug)
    if debug: print(f"Filled: {len(results['filled'])}, Errors: {len(results['errors'])}")
    
    if debug: print("Uploading PDF") 
    await upload_recommendation(page, pdf_path)
    if debug: print("Uploaded PDF")
    
    input("Review the form, then press Enter to continue to next URL (or Ctrl+C to stop)...")

# %% ../nbs/00_core.ipynb 27
def read_info(recc_info:str, pdf_path:str, urls:str):
    "parse CLI args and read input files"
    recc_info, pdf_path = [os.path.expanduser(_) for _ in [recc_info, pdf_path]]
    assert os.path.exists(recc_info), f"File not found: {recc_info}"
    assert os.path.exists(pdf_path), f"File not found: {pdf_path}"
    recc_info = read_text_file(recc_info) 
    letter_text = read_pdf_text(pdf_path)
    if os.path.exists(os.path.expanduser(urls)): 
        print(f"File {urls} exists. Reading.")
        urls = read_urls_file(urls)
    else: 
        print(f"No file {urls}. Treating it as a single url") 
        urls = [urls]
    return recc_info, letter_text, urls 

# %% ../nbs/00_core.ipynb 28
async def setup_browser():
    """Connect to Chrome with remote debugging"""
    from playwright.async_api import async_playwright

    pw = await async_playwright().start()
    browser = await pw.chromium.connect_over_cdp("http://localhost:9222")
    page = await browser.new_page()
    return pw, browser, page

# %% ../nbs/00_core.ipynb 29
async def run_formalyzer(recc_info, letter_text, urls, pdf_path, model, debug=False):
    """Main async workflow"""
    pw, browser, page = await setup_browser()
    try:
        for i, url in enumerate(urls):
            if not url.strip(): continue  # skip empty urls
            print(f"\nURL {i+1} of {len(urls)}: {url}")
            await process_url(page, url, recc_info, letter_text, pdf_path, model, debug=debug)
    finally:
        await browser.close()
        await pw.stop()

# %% ../nbs/00_core.ipynb 30
from fastcore.script import call_parse
import asyncio

@call_parse
def main(
    recc_info:str,   # text file with recommender name, address, etc
    pdf_path:str,    # name of PDF recc letter
    urls:str,        # txt file w/ one URL per line
    model:str='ANTHROPIC',  # 'ollama/qwen2.5:14b' for local model
    debug:bool=False,  # best to always turn this on, actually
    ):
    recc_info, letter_text, urls = read_info(recc_info, pdf_path, urls)
    if model.upper() == 'ANTHROPIC': model = 'claude-sonnet-4-20250514'
    if debug:
        print(f"recc_info ({len(recc_info)} characters) =\n", recc_info)
        print(f"letter_text ({len(letter_text)} characters)=\n", letter_text)
        print("urls =\n", urls)
    
    # Run the async workflow
    asyncio.run(run_formalyzer(recc_info, letter_text, urls, pdf_path, model, debug))
